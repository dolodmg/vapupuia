import type http from 'node:http';
import { WebSocketServer, type WebSocket } from 'ws';
import { decodeMuLaw } from '../audio/mulaw.js';
import { streamTextToSpeech } from '../tts/elevenLabsClient.js';
import { NoopTranscriber } from '../transcription/noopTranscriber.js';
import { averageVolume } from '../util/audioMetrics.js';

interface SessionState {
  callSid: string;
  streamSid: string;
  socket: WebSocket;
  lastInboundAt: number;
  speechDetectedAt?: number;
  outboundInFlight: boolean;
  lastSpeechEndedAt?: number;
  greetingSent: boolean;
  greetingCompleted: boolean; // ‚úÖ Nueva flag para saber cu√°ndo termin√≥ el saludo
  speechFramesCount: number; // ‚úÖ Contador de frames con voz detectada
}

interface CreateServerOptions {
  server: http.Server;
  path: string;
}

const DEFAULT_GENERIC_REPLY = 'Gracias por comunicarte. Estamos procesando tu solicitud.';
const RESPONSE_DELAY_MS = 100;
const SPEECH_THRESHOLD = 800;
const MIN_SPEECH_FRAMES = 15; // ‚úÖ M√≠nimo ~300ms de voz real (15 frames * 20ms)
const ENABLE_ECHO_BACK = process.env.ECHO_BACK === 'true';

export const createMediaStreamServer = ({ server, path }: CreateServerOptions): void => {
  console.log('Modo eco habilitado:', ENABLE_ECHO_BACK);
  console.log('üîß Creando WebSocket Server en path:', path);

  const wss = new WebSocketServer({ noServer: true });
  const sessions = new Map<string, SessionState>();
  const transcriber = new NoopTranscriber();

  console.log('‚úÖ WebSocket Server creado');

  server.on('upgrade', (req, socket, head) => {
    console.log('üîÑ Upgrade request recibido:', req.url);
    console.log('üîÑ Headers:', req.headers);
    
    if (!req.url?.startsWith(path)) {
      console.log('‚ùå URL no coincide con path, destruyendo socket');
      socket.destroy();
      return;
    }

    console.log('‚úÖ URL coincide, haciendo handleUpgrade...');
    wss.handleUpgrade(req, socket, head, (ws) => {
      console.log('‚úÖ handleUpgrade completado, emitiendo connection');
      wss.emit('connection', ws, req);
    });
  });

  wss.on('connection', (socket, request) => {
    console.log('üéâ CONNECTION EVENT DISPARADO!!!');
    const urlParams = new URLSearchParams(request.url?.split('?')[1] ?? '');
    const callSid = urlParams.get('callSid') ?? 'unknown';

    console.log(`Conexi√≥n Media Stream iniciada para callSid=${callSid}`);

    let session: SessionState | undefined;

    socket.on('message', async (data) => {
      let payload: any;
      try {
        payload = JSON.parse(data.toString());
      } catch (error) {
        console.error('Mensaje inv√°lido recibido:', error);
        return;
      }

      console.log('üì® Mensaje recibido:', payload.event);

      switch (payload.event) {
        case 'start':
          const actualCallSid = payload.start.callSid || callSid;
          
          session = {
            callSid: actualCallSid,
            streamSid: payload.start.streamSid,
            socket,
            lastInboundAt: Date.now(),
            outboundInFlight: false,
            greetingSent: false,
            greetingCompleted: false, // ‚úÖ Inicializar en false
            speechFramesCount: 0, // ‚úÖ Inicializar contador
          };
          sessions.set(actualCallSid, session);
          console.log(`‚úÖ Stream iniciado - callSid=${actualCallSid}, streamSid=${payload.start.streamSid}`);
          console.log(`üìã Tracks disponibles:`, payload.start.tracks);
          
          // Enviar saludo inicial
          const greetingText = process.env.GREETING_TEXT ?? 'Hola, bienvenido. ¬øEn qu√© puedo ayudarte?';
          console.log('üëã Preparando saludo:', greetingText);
          sendGreeting(session, greetingText).catch(err => {
            console.error('Error enviando saludo:', err);
          });
          
          break;

        case 'media':
          if (!session) {
            return;
          }
          session.lastInboundAt = Date.now();
          {
            const chunk = Buffer.from(payload.media.payload, 'base64');
            const pcm = decodeMuLaw(chunk);
            const volume = averageVolume(pcm);

            const isSpeech = volume > SPEECH_THRESHOLD;

            // ‚úÖ SOLO detectar voz del usuario DESPU√âS de que termin√≥ el saludo
            if (isSpeech && !session.outboundInFlight && session.greetingCompleted) {
              if (!session.speechDetectedAt) {
                console.log('üé§ Detecci√≥n de voz inbound (volumen:', volume, ')');
                session.speechDetectedAt = Date.now();
                session.speechFramesCount = 0; // Reset contador
              }
              session.speechFramesCount++; // ‚úÖ Incrementar contador de frames con voz
              session.lastSpeechEndedAt = undefined;
              transcriber.handleAudio(pcm);
            } else if (!isSpeech && session.speechDetectedAt && !session.outboundInFlight) {
              // ‚úÖ Solo responder si hubo suficientes frames de voz real
              if (session.speechFramesCount >= MIN_SPEECH_FRAMES) {
                if (!session.lastSpeechEndedAt) {
                  console.log(`ü§´ Usuario dej√≥ de hablar (${session.speechFramesCount} frames detectados)`);
                  session.lastSpeechEndedAt = Date.now();
                }

                if (Date.now() - session.lastSpeechEndedAt > RESPONSE_DELAY_MS) {
                  console.log('üéØ Enviando respuesta tras', RESPONSE_DELAY_MS, 'ms de silencio');
                  session.outboundInFlight = true;
                  
                  session.speechDetectedAt = undefined;
                  session.lastSpeechEndedAt = undefined;
                  session.speechFramesCount = 0; // Reset contador
                  
                  const currentSession = session;
                  sendGenericReply(currentSession).catch((error) => {
                    console.error('‚ùå Error enviando respuesta ElevenLabs', error);
                    currentSession.outboundInFlight = false;
                  });
                }
              } else {
                // Fue ruido breve, no voz real - resetear
                console.log(`‚ö†Ô∏è  Ruido breve detectado (${session.speechFramesCount} frames), ignorando...`);
                session.speechDetectedAt = undefined;
                session.speechFramesCount = 0;
                session.lastSpeechEndedAt = undefined;
              }
            }
          }
          break;

        case 'mark':
          console.log('Marca recibida:', payload);
          // ‚úÖ Detectar cuando termin√≥ el saludo
          if (session && payload.mark?.name === 'greeting_complete') {
            session.greetingCompleted = true;
            console.log('‚úÖ Saludo completado - ahora escuchando al cliente');
          }
          break;

        case 'stop':
          if (session) {
            sessions.delete(session.callSid);
          }
          console.log(`Stream finalizado callSid=${callSid}`);
          break;

        default:
          console.log('Evento desconocido:', payload.event);
          break;
      }
    });

    socket.on('close', () => {
      if (session) {
        sessions.delete(session.callSid);
      }
      console.log(`Socket cerrado callSid=${callSid}`);
    });

    socket.on('error', (error) => {
      console.error('‚ùå Error en WebSocket:', error);
    });
  });
};

const sendGreeting = async (session: SessionState, text: string): Promise<void> => {
  const voiceId = process.env.ELEVENLABS_VOICE_ID;
  const apiKey = process.env.ELEVENLABS_API_KEY;

  if (!voiceId || !apiKey) {
    console.warn('‚ö†Ô∏è  No se puede enviar saludo - falta configuraci√≥n');
    session.greetingSent = true;
    session.greetingCompleted = true; // ‚úÖ Marcar como completado incluso si falla
    return;
  }

  console.log('üëã Enviando saludo inicial...');
  console.log('   VoiceID:', voiceId.substring(0, 8) + '...');
  console.log('   Texto:', text);

  let chunkNumber = 1;

  try {
    // ‚úÖ Enviar directamente, sin buffering
    await streamTextToSpeech({
      text,
      apiKey,
      voiceId,
      onChunk: (chunk) => {
        if (session.socket.readyState !== session.socket.OPEN) {
          console.warn('‚ö†Ô∏è  Socket cerrado durante greeting');
          return;
        }

        const message = JSON.stringify({
          event: 'media',
          streamSid: session.streamSid,
          media: {
            track: 'outbound',
            chunk: String(chunkNumber),
            timestamp: String(Date.now()),
            payload: chunk.toString('base64')
          }
        });

        session.socket.send(message);
        
        if (chunkNumber === 1 || chunkNumber % 50 === 0) {
          console.log(`üëã Greeting chunk ${chunkNumber} enviado`);
        }
        
        chunkNumber++;
      },
    });

    console.log(`‚úÖ Saludo inicial enviado (${chunkNumber - 1} chunks)`);
    
    if (session.socket.readyState === session.socket.OPEN) {
      session.socket.send(
        JSON.stringify({
          event: 'mark',
          streamSid: session.streamSid,
          mark: {
            name: 'greeting_complete'
          }
        })
      );
      console.log('üèÅ Marca "greeting_complete" enviada');
    }
  } catch (error) {
    console.error('‚ùå Error enviando saludo:', error);
    if (error instanceof Error) {
      console.error('   Message:', error.message);
    }
  } finally {
    session.greetingSent = true;
    console.log('‚úÖ greetingSent = true');
  }
};

const sendGenericReply = async (session: SessionState): Promise<void> => {
  const text = process.env.GENERIC_REPLY_TEXT ?? DEFAULT_GENERIC_REPLY;
  const voiceId = process.env.ELEVENLABS_VOICE_ID;
  const apiKey = process.env.ELEVENLABS_API_KEY;

  console.log('üîä Iniciando respuesta ElevenLabs');
  console.log('   Texto:', text);

  if (!voiceId || !apiKey) {
    console.warn('‚ö†Ô∏è  Falta ELEVENLABS_VOICE_ID o ELEVENLABS_API_KEY');
    session.outboundInFlight = false;
    return;
  }

  const startedAt = Date.now();
  let chunkNumber = 1;

  try {
    console.log('üì° Llamando a ElevenLabs API...');
    
    // ‚úÖ Enviar directamente, sin buffering ni delays
    await streamTextToSpeech({
      text,
      apiKey,
      voiceId,
      onChunk: (chunk) => {
        if (session.socket.readyState !== session.socket.OPEN) {
          console.warn('‚ö†Ô∏è  Socket cerrado, no se puede enviar');
          return;
        }

        const message = JSON.stringify({
          event: 'media',
          streamSid: session.streamSid,
          media: {
            track: 'outbound',
            chunk: String(chunkNumber),
            timestamp: String(Date.now()),
            payload: chunk.toString('base64')
          }
        });

        if (chunkNumber === 1 || chunkNumber % 50 === 0) {
          console.log(`üì§ Chunk ${chunkNumber} enviado`);
        }
        
        session.socket.send(message);
        chunkNumber++;
      },
    });

    console.log(`‚úÖ Total chunks enviados: ${chunkNumber - 1}`);

    if (session.socket.readyState === session.socket.OPEN) {
      session.socket.send(
        JSON.stringify({
          event: 'mark',
          streamSid: session.streamSid,
          mark: {
            name: 'audio_complete'
          }
        })
      );
      console.log('üèÅ Marca "audio_complete" enviada');
    }

    console.log(`‚úÖ Respuesta ElevenLabs enviada en ${Date.now() - startedAt} ms`);
  } catch (error) {
    console.error('‚ùå Error en streamTextToSpeech:', error);
    throw error;
  } finally {
    session.outboundInFlight = false;
    console.log('‚ôªÔ∏è  Listo para detectar nueva voz');
  }
};